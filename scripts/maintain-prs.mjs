#!/usr/bin/env node
import { spawnSync } from 'node:child_process';
import process from 'node:process';

const CATEGORY_DEFINITIONS = [
  {
    key: 'ci',
    lotLabel: 'ci',
    titleKeywords: ['ci', 'workflow', 'build', 'lint', 'eslint', 'vite', 'node', 'infrastructure', 'infra', 'pipeline'],
    pathPatterns: [
      /^\.github\//,
      /\/workflow/,
      /package-lock\.json$/,
      /pnpm-lock\.yaml$/,
      /bun\.lockb$/,
      /vite\.config/,
      /tailwind\.config/,
      /eslint/,
      /postcss\.config/,
      /tsconfig/,
    ],
  },
  {
    key: 'security',
    lotLabel: 'security',
    titleKeywords: ['security', 'auth', 'proxy', 'token', 'edge'],
    pathPatterns: [/auth/i, /proxy/i, /edge/i],
  },
  {
    key: 'supabase',
    lotLabel: 'supabase',
    titleKeywords: ['supabase', 'worker', 'queue', 'trigger'],
    pathPatterns: [/supabase/i, /worker/i, /queue/i],
  },
  {
    key: 'studio',
    lotLabel: 'studio',
    titleKeywords: ['studio', 'library', 'asset', 'preview', 'ux', 'ui'],
    pathPatterns: [/apps\/studio/i, /studio/i],
  },
  {
    key: 'cloudinary',
    lotLabel: 'cloudinary',
    titleKeywords: ['cloudinary', 'url', 'generation', 'carousel', 'carrousel', 'upload'],
    pathPatterns: [/cloudinary/i],
  },
  {
    key: 'migrations',
    lotLabel: 'migrations',
    titleKeywords: ['migration', 'prisma', 'bootstrap'],
    pathPatterns: [/prisma/i, /migrations?/i, /db\//i],
  },
];

const CATEGORY_ORDER = CATEGORY_DEFINITIONS.map((c) => c.key);
const RESERVED_LABELS = ['do-not-touch', 'needs-spec', 'security-review', 'wip'];

function parseArgs(argv) {
  let dryRun = true;
  let batch = 'all';
  for (const arg of argv) {
    if (arg === '--dry-run') {
      dryRun = true;
    } else if (arg === '--no-dry-run' || arg === '--run') {
      dryRun = false;
    } else if (arg.startsWith('--batch=')) {
      batch = arg.split('=')[1] || 'all';
    }
  }
  return { dryRun, batch };
}

function runGh(args) {
  const result = spawnSync('gh', args, { encoding: 'utf8' });
  if (result.error) {
    throw new Error(`gh ${args.join(' ')} failed: ${result.error.message}`);
  }
  if (result.status !== 0) {
    const raw = (result.stderr || result.stdout || '').trim();
    const hint = raw || 'GH CLI returned no output — ensure GitHub CLI is installed and authenticated.';
    throw new Error(`gh ${args.join(' ')} failed: ${hint}`);
  }
  return result.stdout;
}

function safeRunGh(args) {
  try {
    return runGh(args);
  } catch (error) {
    console.error(error.message);
    return null;
  }
}

function normalize(str) {
  return (str || '').toLowerCase();
}

function categorize(pr, filePaths) {
  const title = normalize(pr.title);
  for (const definition of CATEGORY_DEFINITIONS) {
    const hasKeyword = definition.titleKeywords.some((kw) => title.includes(kw));
    const hasPathMatch = filePaths.some((path) => definition.pathPatterns.some((pattern) => pattern.test(path)));
    if (hasKeyword || hasPathMatch) {
      return definition.key;
    }
  }
  return 'uncategorized';
}

function detectHeavyConflict(files) {
  const hasLockfile = files.some((path) => /(^|\/)package-lock\.json$/.test(path));
  const conflictConfigs = [/^\.github\/workflows\//, /tsconfig/i, /eslint/i, /vite\.config/i, /tailwind\.config/i, /next\.config/i];
  const hasConfig = files.some((path) => conflictConfigs.some((pattern) => pattern.test(path)));
  if (hasLockfile && hasConfig) {
    const configs = files.filter((path) => conflictConfigs.some((pattern) => pattern.test(path)));
    return { flag: true, details: configs.slice(0, 3) };
  }
  return { flag: false, details: [] };
}

function formatComment({ dryRun, lotLabel, baseRef, orderIndex, lotSize, heavyConflict, headRef, number }) {
  const conflictLine = heavyConflict.flag
    ? `oui (verifier ${heavyConflict.details.join(', ')})`
    : 'non';
  const lines = [
    `Maintenance bot (DRY_RUN=${dryRun ? 'true' : 'false'})`,
    '',
    `• Lot: ${lotLabel}${lotSize > 0 ? ` — position ${orderIndex + 1}/${lotSize}` : ''}`,
    `• Base: ${baseRef} → rebase planned`,
    `• Branche: ${headRef}`,
    '• Étapes: rebase → run checks → (squash-merge | close+delete)',
    '• Garde-fous: no protected branches, no previews deleted, force-with-lease only',
    `• Conflits lourds potentiels: ${conflictLine}`,
    '',
    '_Generated by scripts/maintain-prs.mjs_'
  ];
  return lines.join('\n');
}

function summarizeLots(lots) {
  const summary = [];
  for (const [key, prs] of lots) {
    const entries = prs.map((pr, index) => `#${pr.number} (${pr.title}) [${index + 1}/${prs.length}]`).join('; ');
    summary.push(`${key}: ${entries || 'aucune PR'}`);
  }
  return summary.join('\n');
}

async function main() {
  const { dryRun, batch } = parseArgs(process.argv.slice(2));
  console.log(`Running maintain-prs with DRY_RUN=${dryRun} batch=${batch}`);

  const listOutput = safeRunGh(['pr', 'list', '--state', 'open', '--json', 'number,title,headRefName,baseRefName,labels,updatedAt']);
  if (!listOutput) {
    process.exitCode = 1;
    return;
  }

  const prs = JSON.parse(listOutput);
  const filtered = [];
  for (const pr of prs) {
    const labels = (pr.labels || []).map((label) => normalize(label.name));
    const hasReservedLabel = labels.some((label) => RESERVED_LABELS.includes(label));
    if (hasReservedLabel) {
      console.log(`Skipping PR #${pr.number} due to reserved label`);
      continue;
    }
    const viewOutput = safeRunGh(['pr', 'view', String(pr.number), '--json', 'files']);
    if (!viewOutput) {
      continue;
    }
    const details = JSON.parse(viewOutput);
    const files = (details.files || []).map((file) => file.path);
    const category = categorize(pr, files);
    const heavyConflict = detectHeavyConflict(files);
    filtered.push({
      number: pr.number,
      title: pr.title,
      baseRefName: pr.baseRefName,
      headRefName: pr.headRefName,
      labels,
      category,
      files,
      heavyConflict,
    });
  }

  const lots = new Map();
  for (const category of CATEGORY_ORDER) {
    lots.set(category, []);
  }
  lots.set('uncategorized', []);

  for (const pr of filtered) {
    if (batch !== 'all' && pr.category !== batch) {
      console.log(`Skipping PR #${pr.number} (category ${pr.category}) outside batch ${batch}`);
      continue;
    }
    lots.get(pr.category)?.push(pr);
  }

  for (const [key, prsInLot] of lots) {
    prsInLot.sort((a, b) => a.number - b.number);
    prsInLot.forEach((pr, index) => {
      pr.orderIndex = index;
      pr.lotSize = prsInLot.length;
      pr.lotLabel = key;
    });
  }

  for (const [key, prsInLot] of lots) {
    for (const pr of prsInLot) {
      const body = formatComment({
        dryRun,
        lotLabel: key,
        baseRef: pr.baseRefName,
        orderIndex: pr.orderIndex,
        lotSize: pr.lotSize,
        heavyConflict: pr.heavyConflict,
        headRef: pr.headRefName,
        number: pr.number,
      });
      console.log(`Preparing comment for PR #${pr.number} (lot ${key})`);
      if (!dryRun) {
        console.log(`Would execute actions for PR #${pr.number}`);
      }
      const commentResult = safeRunGh(['pr', 'comment', String(pr.number), '--body', body]);
      if (commentResult === null) {
        console.error(`Failed to comment on PR #${pr.number}`);
      }
    }
  }

  console.log('Lot summary:\n' + summarizeLots(lots));
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
